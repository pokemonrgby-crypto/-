<!DOCTYPE html>
<html lang="ko" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 캐릭터 챗</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <style>
        :root {
            --bg-color-light: #f7f8fa;
            --bg-color-dark: #1e1e1e;
            --text-color-light: #1f2937;
            --text-color-dark: #f9fafb;
            --sidebar-bg-light: #ffffff;
            --sidebar-bg-dark: #2a2a2a;
            --border-color-light: #e5e7eb;
            --border-color-dark: #4b5563;
            --user-msg-bg-light: #e0f2fe;
            --user-msg-bg-dark: #0c4a6e;
            --ai-msg-bg-light: #f3f4f6;
            --ai-msg-bg-dark: #374151;
            --button-bg-light: #3b82f6;
            --button-bg-dark: #60a5fa;
            --hover-bg-light: #f0f0f0;
            --hover-bg-dark: #4a4a4a;
        }

        /* 스크롤바 스타일 */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        .dark ::-webkit-scrollbar-thumb { background: #555; }
        .dark ::-webkit-scrollbar-thumb:hover { background: #888; }
        
        /* 기본 폰트 및 배경 설정 */
        body {
            font-family: 'Pretendard', sans-serif;
            background-color: var(--bg-color-light);
            color: var(--text-color-light);
        }
        .dark body {
            background-color: var(--bg-color-dark);
            color: var(--text-color-dark);
        }
        
        /* 메시지 애니메이션 */
        .message-item {
            animation: slideUp 0.3s ease-out forwards;
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 버튼 및 입력 필드 포커스 스타일 */
        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
            border-color: #3b82f6;
        }

        /* 모바일에서 텍스트 줄바꿈 방지 */
        .no-wrap {
            white-space: nowrap;
        }

    </style>
</head>
<body class="antialiased">

    <div id="app" class="relative w-screen h-screen overflow-hidden flex transition-colors duration-300">

        <div id="apiKeyModal" class="absolute inset-0 z-50 flex items-center justify-center bg-gray-900 bg-opacity-80">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-8 w-11/12 max-w-md">
                <h2 class="text-2xl font-bold mb-4 text-gray-800 dark:text-gray-100">Gemini API 키 입력</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-6">채팅을 시작하려면 API 키를 입력해주세요. 키는 브라우저에만 저장됩니다.</p>
                <input type="password" id="apiKeyInput" class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-gray-200 form-input" placeholder="API 키를 여기에 붙여넣으세요">
                <button id="saveApiKey" class="w-full mt-6 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-all duration-200">
                    저장하고 시작하기
                </button>
            </div>
        </div>

        <aside id="sidebar" class="absolute top-0 left-0 h-full bg-sidebar-bg-light dark:bg-sidebar-bg-dark border-r border-border-color-light dark:border-border-color-dark w-full md:w-80 lg:w-96 z-40 transform -translate-x-full md:relative md:translate-x-0 transition-transform duration-300 ease-in-out flex flex-col">
            <div class="p-4 border-b border-border-color-light dark:border-border-color-dark flex justify-between items-center">
                <h1 class="text-xl font-bold no-wrap">AI 캐릭터 설정</h1>
                <div class="flex items-center">
                    <button id="themeToggleBtn" class="p-2 rounded-full hover:bg-hover-bg-light dark:hover:bg-hover-bg-dark focus:outline-none">
                        <svg class="w-5 h-5 block dark:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                        <svg class="w-5 h-5 hidden dark:block" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                    </button>
                    <button id="sidebarCloseBtn" class="md:hidden p-2 rounded-full hover:bg-hover-bg-light dark:hover:bg-hover-bg-dark focus:outline-none">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>

            <div class="flex-grow overflow-y-auto p-4 space-y-6">
                <div>
                    <h3 class="font-semibold mb-2">캐릭터</h3>
                    <div class="flex space-x-2">
                        <select id="characterSelect" class="w-full form-select px-3 py-2 border rounded-md bg-gray-50 dark:bg-gray-700 border-gray-300 dark:border-gray-600"></select>
                        <button id="newCharBtn" class="p-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 no-wrap">추가</button>
                        <button id="deleteCharBtn" class="p-2 bg-red-500 text-white rounded-md hover:bg-red-600 no-wrap">삭제</button>
                    </div>
                </div>

                <div>
                    <h3 class="font-semibold mb-2">캐릭터 프로필</h3>
                    <div class="flex items-center space-x-4">
                        <div class="w-16 h-16 rounded-full bg-gray-200 dark:bg-gray-600 flex items-center justify-center overflow-hidden">
                            <img id="charProfileImg" class="w-full h-full object-cover hidden" src="" alt="Character Profile">
                            <svg id="charProfileIcon" class="w-10 h-10 text-gray-400 dark:text-gray-500" fill="currentColor" viewBox="0 0 24 24"><path d="M24 20.993V24H0v-2.996A14.977 14.977 0 0112.004 15c4.904 0 9.26 2.354 11.996 5.993zM16.002 8.999a4 4 0 11-8 0 4 4 0 018 0z" /></svg>
                        </div>
                        <input type="file" id="imageUpload" class="hidden" accept="image/*">
                        <button onclick="document.getElementById('imageUpload').click()" class="px-3 py-1.5 text-sm font-semibold border rounded-md hover:bg-hover-bg-light dark:hover:bg-hover-bg-dark no-wrap">이미지 변경</button>
                    </div>
                </div>
                 
                <div>
                    <label for="modelSelect" class="block font-semibold mb-2">AI 모델</label>
                    <select id="modelSelect" class="w-full form-select px-3 py-2 border rounded-md bg-gray-50 dark:bg-gray-700 border-gray-300 dark:border-gray-600">
                        <option>gemini-1.5-flash-latest</option>
                        <option>gemini-1.5-pro-latest</option>
                        <option>gemini-pro</option>
                    </select>
                </div>
                
                <div>
                    <label for="userNameInput" class="block font-semibold mb-2">사용자 이름</label>
                    <input type="text" id="userNameInput" class="w-full form-input px-3 py-2 border rounded-md bg-gray-50 dark:bg-gray-700 border-gray-300 dark:border-gray-600" placeholder="AI가 당신을 부를 이름">
                </div>

                <div>
                    <label for="systemPrompt" class="block font-semibold mb-2">시스템 프롬프트 (AI 역할 부여)</label>
                    <textarea id="systemPrompt" rows="8" class="w-full form-textarea px-3 py-2 border rounded-md bg-gray-50 dark:bg-gray-700 border-gray-300 dark:border-gray-600" placeholder="예: 당신은 유머 감각이 뛰어난 고양이 챗봇입니다. 모든 대답을 '냥'으로 끝내세요."></textarea>
                </div>
            </div>
            
            <div class="p-4 border-t border-border-color-light dark:border-border-color-dark">
                 <button id="resetApiKey" class="w-full text-sm text-gray-500 hover:text-red-500 dark:hover:text-red-400">API 키 재설정</button>
            </div>
        </aside>

        <main id="chatArea" class="flex-1 flex flex-col h-full bg-bg-color-light dark:bg-bg-color-dark transition-all duration-300">
            <header class="flex items-center justify-between p-3 border-b border-border-color-light dark:border-border-color-dark">
                 <div class="flex items-center">
                    <button id="sidebarOpenBtn" class="md:hidden p-2 mr-2 rounded-full hover:bg-hover-bg-light dark:hover:bg-hover-bg-dark">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                    </button>
                    <h2 id="chatHeaderTitle" class="text-lg font-semibold">대화 시작하기</h2>
                </div>
                <div class="relative">
                    <button id="chatMenuBtn" class="p-2 rounded-full hover:bg-hover-bg-light dark:hover:bg-hover-bg-dark">
                         <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"></path></svg>
                    </button>
                    <div id="chatMenu" class="hidden absolute right-0 mt-2 w-48 bg-white dark:bg-gray-700 rounded-md shadow-lg z-20">
                        <a href="#" id="newChatBtn" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">새 대화 시작</a>
                        <a href="#" id="exportMarkdownBtn" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">Markdown으로 내보내기</a>
                        <a href="#" id="exportJsonBtn" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">JSON으로 내보내기</a>
                    </div>
                </div>
            </header>

            <div id="messageList" class="flex-1 overflow-y-auto p-4 md:p-6 space-y-6">
                </div>

            <div class="p-4 md:p-6 border-t border-border-color-light dark:border-border-color-dark">
                <form id="chatForm" class="flex items-start space-x-3">
                    <textarea id="messageInput" class="flex-1 resize-none form-textarea p-3 border rounded-lg bg-gray-50 dark:bg-gray-700 border-gray-300 dark:border-gray-600 focus:ring-2 focus:ring-blue-500" placeholder="메시지를 입력하세요..." rows="1"></textarea>
                    <button type="submit" class="h-12 w-12 flex-shrink-0 bg-blue-500 hover:bg-blue-600 text-white rounded-lg flex items-center justify-center disabled:bg-gray-400 disabled:cursor-not-allowed">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                    </button>
                </form>
            </div>
        </main>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- STATE MANAGEMENT ---
    const state = {
        apiKey: null,
        characters: [],
        activeCharacterId: null,
        currentConversation: [],
        isStreaming: false,
        theme: 'light',
    };

    // --- DOM ELEMENTS ---
    const dom = {
        app: document.getElementById('app'),
        apiKeyModal: document.getElementById('apiKeyModal'),
        apiKeyInput: document.getElementById('apiKeyInput'),
        saveApiKeyBtn: document.getElementById('saveApiKey'),
        resetApiKeyBtn: document.getElementById('resetApiKey'),
        sidebar: document.getElementById('sidebar'),
        sidebarOpenBtn: document.getElementById('sidebarOpenBtn'),
        sidebarCloseBtn: document.getElementById('sidebarCloseBtn'),
        chatArea: document.getElementById('chatArea'),
        messageList: document.getElementById('messageList'),
        chatForm: document.getElementById('chatForm'),
        messageInput: document.getElementById('messageInput'),
        chatHeaderTitle: document.getElementById('chatHeaderTitle'),
        themeToggleBtn: document.getElementById('themeToggleBtn'),
        characterSelect: document.getElementById('characterSelect'),
        newCharBtn: document.getElementById('newCharBtn'),
        deleteCharBtn: document.getElementById('deleteCharBtn'),
        modelSelect: document.getElementById('modelSelect'),
        userNameInput: document.getElementById('userNameInput'),
        systemPrompt: document.getElementById('systemPrompt'),
        imageUpload: document.getElementById('imageUpload'),
        charProfileImg: document.getElementById('charProfileImg'),
        charProfileIcon: document.getElementById('charProfileIcon'),
        chatMenuBtn: document.getElementById('chatMenuBtn'),
        chatMenu: document.getElementById('chatMenu'),
        newChatBtn: document.getElementById('newChatBtn'),
        exportMarkdownBtn: document.getElementById('exportMarkdownBtn'),
        exportJsonBtn: document.getElementById('exportJsonBtn'),
    };

    // --- LOCAL STORAGE UTILS ---
    const storage = {
        save: (key, value) => localStorage.setItem(key, JSON.stringify(value)),
        load: (key) => {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : null;
        },
        remove: (key) => localStorage.removeItem(key),
    };
    
    // --- UTILITY FUNCTIONS ---
    const utils = {
        generateId: () => `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        readerToAsyncIterator: async function* (reader) {
            const decoder = new TextDecoder();
            while (true) {
                const { done, value } = await reader.read();
                if (done) return;
                yield decoder.decode(value, { stream: true });
            }
        },
        escapeHtml: (str) => str.replace(/[&<>"']/g, (match) => ({
            '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
        }[match])),
    };
    
    // --- UI LOGIC ---

    const ui = {
        updateTheme: () => {
            const html = document.documentElement;
            if (state.theme === 'dark') {
                html.classList.add('dark');
            } else {
                html.classList.remove('dark');
            }
            // Update highlight.js theme if needed. This requires loading two themes.
            // For simplicity, we stick to one theme that works for both backgrounds.
        },
        toggleSidebar: (show) => {
            if (show) {
                dom.sidebar.classList.remove('-translate-x-full');
            } else {
                dom.sidebar.classList.add('-translate-x-full');
            }
        },
        renderCharacters: () => {
            dom.characterSelect.innerHTML = '';
            if (state.characters.length === 0) {
                const option = document.createElement('option');
                option.textContent = "새 캐릭터를 추가하세요";
                option.disabled = true;
                dom.characterSelect.appendChild(option);
                return;
            }
            state.characters.forEach(char => {
                const option = document.createElement('option');
                option.value = char.id;
                option.textContent = char.name || '이름 없는 캐릭터';
                if (char.id === state.activeCharacterId) {
                    option.selected = true;
                }
                dom.characterSelect.appendChild(option);
            });
        },
        updateCharacterForm: () => {
            const activeChar = state.characters.find(c => c.id === state.activeCharacterId);
            if (!activeChar) {
                // Clear form if no character is selected or found
                dom.modelSelect.value = 'gemini-1.5-flash-latest';
                dom.userNameInput.value = '';
                dom.systemPrompt.value = '';
                dom.charProfileImg.classList.add('hidden');
                dom.charProfileIcon.classList.remove('hidden');
                dom.chatHeaderTitle.textContent = '대화 시작하기';
                return;
            };

            dom.modelSelect.value = activeChar.model;
            dom.userNameInput.value = activeChar.userName;
            dom.systemPrompt.value = activeChar.systemPrompt;
            dom.chatHeaderTitle.textContent = activeChar.name || '이름 없는 캐릭터';

            if (activeChar.profileImg) {
                dom.charProfileImg.src = activeChar.profileImg;
                dom.charProfileImg.classList.remove('hidden');
                dom.charProfileIcon.classList.add('hidden');
            } else {
                dom.charProfileImg.classList.add('hidden');
                dom.charProfileIcon.classList.remove('hidden');
            }
        },
        renderMessage: (message) => {
            const isUser = message.role === 'user';
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `message-item flex ${isUser ? 'justify-end' : 'justify-start'}`;

            const messageBubble = document.createElement('div');
            messageBubble.className = `max-w-xl lg:max-w-3xl p-4 rounded-2xl ${isUser ? 'bg-user-msg-bg-light dark:bg-user-msg-bg-dark rounded-br-lg' : 'bg-ai-msg-bg-light dark:bg-ai-msg-bg-dark rounded-bl-lg'}`;

            const contentDiv = document.createElement('div');
            contentDiv.className = 'prose prose-sm dark:prose-invert max-w-none message-content';
            contentDiv.innerHTML = message.htmlContent || ''; // Initial content
            if (message.id) contentDiv.id = `content-${message.id}`;

            messageBubble.appendChild(contentDiv);
            messageWrapper.appendChild(messageBubble);
            dom.messageList.appendChild(messageWrapper);

            // Scroll to bottom
            dom.messageList.scrollTop = dom.messageList.scrollHeight;
            
            return contentDiv; // Return the content element for streaming
        },
        renderConversation: () => {
            dom.messageList.innerHTML = '';
            state.currentConversation.forEach(msg => ui.renderMessage(msg));
        },
        adjustTextareaHeight: () => {
            dom.messageInput.style.height = 'auto';
            dom.messageInput.style.height = `${dom.messageInput.scrollHeight}px`;
        }
    };

    // --- APPLICATION LOGIC ---

    const app = {
        init: () => {
            // Load state from storage
            state.apiKey = storage.load('geminiApiKey');
            state.characters = storage.load('characters') || [];
            state.activeCharacterId = storage.load('activeCharacterId');
            state.theme = storage.load('theme') || 'light';

            // Initial UI setup
            ui.updateTheme();
            
            if (!state.apiKey) {
                dom.apiKeyModal.classList.remove('hidden');
                dom.apiKeyModal.classList.add('flex');
            } else {
                dom.apiKeyModal.classList.add('hidden');
                dom.apiKeyModal.classList.remove('flex');
            }

            if(state.characters.length === 0) {
                app.createNewCharacter();
            } else {
                 // Validate activeCharacterId
                if (!state.activeCharacterId || !state.characters.find(c => c.id === state.activeCharacterId)) {
                    state.activeCharacterId = state.characters[0]?.id;
                    storage.save('activeCharacterId', state.activeCharacterId);
                }
            }

            app.loadConversation();
            ui.renderCharacters();
            ui.updateCharacterForm();
            ui.renderConversation();
            app.addEventListeners();
        },

        addEventListeners: () => {
            dom.saveApiKeyBtn.addEventListener('click', app.saveApiKey);
            dom.resetApiKeyBtn.addEventListener('click', app.resetApiKey);
            dom.themeToggleBtn.addEventListener('click', app.toggleTheme);
            dom.sidebarOpenBtn.addEventListener('click', () => ui.toggleSidebar(true));
            dom.sidebarCloseBtn.addEventListener('click', () => ui.toggleSidebar(false));
            dom.chatForm.addEventListener('submit', app.handleSendMessage);
            dom.messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    dom.chatForm.requestSubmit();
                }
            });
            dom.messageInput.addEventListener('input', ui.adjustTextareaHeight);
            
            // Character Management
            dom.newCharBtn.addEventListener('click', app.createNewCharacter);
            dom.deleteCharBtn.addEventListener('click', app.deleteCharacter);
            dom.characterSelect.addEventListener('change', app.switchCharacter);
            
            // Character Form Listeners
            dom.modelSelect.addEventListener('change', (e) => app.updateActiveCharacter({ model: e.target.value }));
            dom.userNameInput.addEventListener('input', (e) => app.updateActiveCharacter({ userName: e.target.value }));
            dom.systemPrompt.addEventListener('input', (e) => app.updateActiveCharacter({ systemPrompt: e.target.value }));
            dom.imageUpload.addEventListener('change', app.handleImageUpload);

            // Chat Menu
            dom.chatMenuBtn.addEventListener('click', () => dom.chatMenu.classList.toggle('hidden'));
            document.addEventListener('click', (e) => {
                if (!dom.chatMenuBtn.contains(e.target) && !dom.chatMenu.contains(e.target)) {
                    dom.chatMenu.classList.add('hidden');
                }
            });
            dom.newChatBtn.addEventListener('click', app.startNewConversation);
            dom.exportMarkdownBtn.addEventListener('click', app.exportConversationMarkdown);
            dom.exportJsonBtn.addEventListener('click', app.exportConversationJson);
        },
        
        saveApiKey: () => {
            const key = dom.apiKeyInput.value.trim();
            if (key) {
                state.apiKey = key;
                storage.save('geminiApiKey', key);
                dom.apiKeyModal.classList.add('hidden');
                dom.apiKeyModal.classList.remove('flex');
            }
        },

        resetApiKey: () => {
            if(confirm('API 키를 삭제하고 재설정하시겠습니까?')) {
                state.apiKey = null;
                storage.remove('geminiApiKey');
                dom.apiKeyModal.classList.remove('hidden');
                dom.apiKeyModal.classList.add('flex');
            }
        },

        toggleTheme: () => {
            state.theme = state.theme === 'light' ? 'dark' : 'light';
            storage.save('theme', state.theme);
            ui.updateTheme();
        },
        
        createNewCharacter: () => {
            const newChar = {
                id: utils.generateId(),
                name: `새 캐릭터 ${state.characters.length + 1}`,
                model: 'gemini-1.5-flash-latest',
                userName: '사용자',
                systemPrompt: '당신은 도움이 되는 어시스턴트입니다.',
                profileImg: null,
            };
            state.characters.push(newChar);
            state.activeCharacterId = newChar.id;
            
            storage.save('characters', state.characters);
            storage.save('activeCharacterId', state.activeCharacterId);
            
            ui.renderCharacters();
            ui.updateCharacterForm();
            app.startNewConversation();
        },
        
        deleteCharacter: () => {
            if(state.characters.length <= 1) {
                alert('최소 한 개의 캐릭터는 남겨두어야 합니다.');
                return;
            }
            if(confirm('이 캐릭터와 모든 대화 기록을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                // Delete conversations associated with this character
                storage.remove(`conversation_${state.activeCharacterId}`);
                
                state.characters = state.characters.filter(c => c.id !== state.activeCharacterId);
                state.activeCharacterId = state.characters[0]?.id;
                
                storage.save('characters', state.characters);
                storage.save('activeCharacterId', state.activeCharacterId);
                
                ui.renderCharacters();
                ui.updateCharacterForm();
                app.loadConversation();
                ui.renderConversation();
            }
        },
        
        switchCharacter: (e) => {
            const newId = e.target.value;
            state.activeCharacterId = newId;
            storage.save('activeCharacterId', state.activeCharacterId);
            
            ui.updateCharacterForm();
            app.loadConversation();
            ui.renderConversation();
        },
        
        updateActiveCharacter: (updates) => {
             let activeChar = state.characters.find(c => c.id === state.activeCharacterId);
             if (activeChar) {
                // If name is updated from input field, handle it here
                if (updates.name) {
                    dom.chatHeaderTitle.textContent = updates.name;
                }
                Object.assign(activeChar, updates);
                storage.save('characters', state.characters);
                // Re-render character list if name changed
                if (updates.name) {
                    ui.renderCharacters();
                }
             }
        },

        handleImageUpload: (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const imageUrl = event.target.result;
                    dom.charProfileImg.src = imageUrl;
                    dom.charProfileImg.classList.remove('hidden');
                    dom.charProfileIcon.classList.add('hidden');
                    app.updateActiveCharacter({ profileImg: imageUrl });
                };
                reader.readAsDataURL(file);
            }
        },
        
        loadConversation: () => {
            if (!state.activeCharacterId) {
                state.currentConversation = [];
                return;
            }
            state.currentConversation = storage.load(`conversation_${state.activeCharacterId}`) || [];
        },
        
        saveConversation: () => {
            if (!state.activeCharacterId) return;
            storage.save(`conversation_${state.activeCharacterId}`, state.currentConversation);
        },

        startNewConversation: () => {
            if(!state.activeCharacterId) return;
            if(state.currentConversation.length > 0 && !confirm('현재 대화를 지우고 새 대화를 시작할까요?')) {
                return;
            }
            state.currentConversation = [];
            app.saveConversation();
            ui.renderConversation();
        },
        
        handleSendMessage: async (e) => {
            e.preventDefault();
            if (state.isStreaming) return;
            
            const userInput = dom.messageInput.value.trim();
            if (!userInput) return;
            
            // Add user message to state and UI
            const userMessage = {
                role: 'user',
                parts: [{ text: userInput }],
                htmlContent: marked.parse(userInput)
            };
            state.currentConversation.push(userMessage);
            ui.renderMessage(userMessage);
            
            dom.messageInput.value = '';
            ui.adjustTextareaHeight();
            
            await app.fetchAiResponse();
        },
        
        fetchAiResponse: async () => {
            state.isStreaming = true;
            dom.chatForm.querySelector('button').disabled = true;

            const activeChar = state.characters.find(c => c.id === state.activeCharacterId);
            
            // Construct history for the API call
            const history = state.currentConversation.slice(0, -1).map(msg => ({
                role: msg.role,
                parts: msg.parts
            }));

            const systemInstruction = {
                role: 'system',
                parts: [{ text: `사용자 이름: ${activeChar.userName}\n\n${activeChar.systemPrompt}` }]
            };
            
            const model = activeChar.model.startsWith('gemini') ? `models/${activeChar.model}` : activeChar.model;
            
            // Add AI message placeholder
            const aiMessageId = utils.generateId();
            const aiMessage = { role: 'model', parts: [{ text: '' }], id: aiMessageId, htmlContent: '' };
            state.currentConversation.push(aiMessage);
            const contentDiv = ui.renderMessage(aiMessage);

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/${model}:streamGenerateContent?key=${state.apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [...history, { role: 'user', parts: state.currentConversation.slice(-2, -1)[0].parts }],
                        systemInstruction,
                    }),
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error.message || 'API 요청에 실패했습니다.');
                }
                
                // --- INTELLIGENT STREAMING RENDERER ---
                let fullText = '';
                const reader = response.body.getReader();
                for await (const chunk of utils.readerToAsyncIterator(reader)) {
                    // Sometimes chunks are not valid JSON, we need to handle this
                    try {
                        const jsonStr = chunk.replace(/^data: /, '').trim();
                        if (jsonStr.startsWith('{')) {
                            const data = JSON.parse(jsonStr);
                            const textPart = data.candidates?.[0]?.content?.parts?.[0]?.text;
                            if (textPart) {
                                fullText += textPart;
                                // Update state
                                aiMessage.parts[0].text = fullText;
                                
                                // Render markdown on the fly
                                let processedHtml = marked.parse(fullText + '▋'); // Add a blinking cursor for effect
                                
                                // Post-process for code blocks
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = processedHtml;
                                
                                tempDiv.querySelectorAll('pre code').forEach((block) => {
                                    const codeContent = block.textContent;
                                    block.parentNode.classList.add('relative');
                                    // Add copy button
                                    const copyBtn = document.createElement('button');
                                    copyBtn.textContent = '복사';
                                    copyBtn.className = 'absolute top-2 right-2 px-2 py-1 text-xs bg-gray-600 text-white rounded hover:bg-gray-700';
                                    copyBtn.onclick = () => {
                                        navigator.clipboard.writeText(codeContent);
                                        copyBtn.textContent = '복사됨!';
                                        setTimeout(() => copyBtn.textContent = '복사', 2000);
                                    };
                                    block.parentNode.appendChild(copyBtn);
                                    hljs.highlightElement(block);
                                });
                                
                                contentDiv.innerHTML = tempDiv.innerHTML;
                                dom.messageList.scrollTop = dom.messageList.scrollHeight;
                            }
                        }
                    } catch (e) {
                         console.warn("Could not parse chunk:", chunk);
                    }
                }
                // Final render without cursor
                 aiMessage.htmlContent = marked.parse(fullText);
                 contentDiv.innerHTML = aiMessage.htmlContent;
                 contentDiv.querySelectorAll('pre code').forEach(hljs.highlightElement);
                 // Re-add copy buttons after final render
                 contentDiv.querySelectorAll('pre code').forEach((block) => {
                    const codeContent = block.textContent;
                    block.parentNode.classList.add('relative');
                    const copyBtn = document.createElement('button');
                    copyBtn.textContent = '복사';
                    copyBtn.className = 'absolute top-2 right-2 px-2 py-1 text-xs bg-gray-600 text-white rounded hover:bg-gray-700';
                    copyBtn.onclick = () => {
                        navigator.clipboard.writeText(codeContent);
                        copyBtn.textContent = '복사됨!';
                        setTimeout(() => copyBtn.textContent = '복사', 2000);
                    };
                    block.parentNode.appendChild(copyBtn);
                 });


            } catch (error) {
                contentDiv.innerHTML = `<p class="text-red-500"><strong>오류:</strong> ${error.message}</p>`;
            } finally {
                state.isStreaming = false;
                dom.chatForm.querySelector('button').disabled = false;
                app.saveConversation();
            }
        },

        exportConversationMarkdown: () => {
            if(state.currentConversation.length === 0) return;
            let markdown = `# ${dom.chatHeaderTitle.textContent} 대화 기록\n\n`;
            state.currentConversation.forEach(msg => {
                const prefix = msg.role === 'user' ? '## 👤 사용자' : '## 🤖 AI';
                markdown += `${prefix}\n\n${msg.parts[0].text}\n\n---\n\n`;
            });
            
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `conversation_${state.activeCharacterId}.md`;
            a.click();
            URL.revokeObjectURL(url);
        },
        
        exportConversationJson: () => {
            if(state.currentConversation.length === 0) return;
            const json = JSON.stringify(state.currentConversation, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `conversation_${state.activeCharacterId}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
    };

    // --- INITIALIZE APP ---
    app.init();
});
</script>
</body>
</html>
